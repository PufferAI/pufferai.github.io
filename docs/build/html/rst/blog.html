<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="prev" title="Squared" href="ocean.html" />

    <!-- Generated with Sphinx 5.0.0 and Furo 2023.03.27 -->
        <title>üê°üåä An Ocean of Environments for Learning Pufferfish - PufferLib 0.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-foreground-primary: black;
  --color-foreground-secondary: #005050;
  --color-foreground-muted: #005050;
  --color-foreground-border: #878787;
  --color-background-primary: white;
  --color-background-secondary: #bbcccc;
  --color-background-hover: #efeff4ff;
  --color-background-hover--transparent: #efeff400;
  --color-background-border: #005050;
  --color-background-item: #ccc;
  --color-announcement-background: #000000dd;
  --color-announcement-text: #eeebee;
  --color-brand-primary: black;
  --color-brand-content: black;
  --color-inline-code-background: #f8f9fb;
  --color-highlighted-background: #ddeeff;
  --color-guilabel-background: #ddeeff80;
  --color-guilabel-border: #bedaf580;
  --color-card-background: #bbcccc;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --color-problematic: #ee5151;
  --color-foreground-primary: #f1f1f1;
  --color-foreground-secondary: #00bbbb;
  --color-foreground-muted: #00bbbb;
  --color-foreground-border: #666666;
  --color-background-primary: #061a1a;
  --color-background-secondary: #000000;
  --color-background-hover: #1e2124ff;
  --color-background-hover--transparent: #1e212400;
  --color-background-border: #303335;
  --color-background-item: #444;
  --color-announcement-background: #000000dd;
  --color-announcement-text: #eeebee;
  --color-brand-primary: #00bbbb;
  --color-brand-content: #00bbbb;
  --color-highlighted-background: #083563;
  --color-guilabel-background: #08356380;
  --color-guilabel-border: #13395f80;
  --color-admonition-background: #18181a;
  --color-card-border: #1a1c1e;
  --color-card-background: #000000;
  --color-card-marginals-background: #1e2124ff;
  --color-inline-code-background: #00000000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --color-problematic: #ee5151;
  --color-foreground-primary: #f1f1f1;
  --color-foreground-secondary: #00bbbb;
  --color-foreground-muted: #00bbbb;
  --color-foreground-border: #666666;
  --color-background-primary: #061a1a;
  --color-background-secondary: #000000;
  --color-background-hover: #1e2124ff;
  --color-background-hover--transparent: #1e212400;
  --color-background-border: #303335;
  --color-background-item: #444;
  --color-announcement-background: #000000dd;
  --color-announcement-text: #eeebee;
  --color-brand-primary: #00bbbb;
  --color-brand-content: #00bbbb;
  --color-highlighted-background: #083563;
  --color-guilabel-background: #08356380;
  --color-guilabel-border: #13395f80;
  --color-admonition-background: #18181a;
  --color-card-border: #1a1c1e;
  --color-card-background: #000000;
  --color-card-marginals-background: #1e2124ff;
  --color-inline-code-background: #00000000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">PufferLib 0.6.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">PufferLib 0.6.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="landing.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="landing.html#environments">Environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="landing.html#current-limitations">Current Limitations</a></li>
<li class="toctree-l1"><a class="reference internal" href="landing.html#license">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#environments">Environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#models">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#vectorization">Vectorization</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#cleanrl-integration">CleanRL Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#sb3-binding">SB3 Binding</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#rllib-binding">RLlib Binding</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">üåä Ocean</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ocean.html">Squared</a></li>
<li class="toctree-l1"><a class="reference internal" href="ocean.html#password-exploration-environment">Password (exploration environment)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ocean.html#stochastic">Stochastic</a></li>
<li class="toctree-l1"><a class="reference internal" href="ocean.html#memory">Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="ocean.html#bandit">Bandit</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Blog</span></p>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">üê°üåä An Ocean of Environments for Learning Pufferfish</a></li>
<li class="toctree-l1"><a class="reference internal" href="#pufferlib-0-5-a-bigger-envpool-for-growing-puffers">PufferLib 0.5: A Bigger EnvPool for Growing Puffers</a></li>
<li class="toctree-l1"><a class="reference internal" href="#pufferlib-0-4-ready-to-take-on-bigger-fish">PufferLib 0.4: Ready to Take on Bigger Fish</a></li>
<li class="toctree-l1"><a class="reference internal" href="#pufferlib-0-2-ready-to-take-on-the-big-fish">PufferLib 0.2: Ready to Take on the Big Fish</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <center>
  <video width=100% height="auto" nocontrols autoplay playsinline muted loop>
    <source src="../_static/banner.webm" type="video/webm">
    <source src="../_static/banner.mp4" type="video/mp4">
    Your browser does not support this video.
  </video>
</center><section id="an-ocean-of-environments-for-learning-pufferfish">
<h1>üê°üåä An Ocean of Environments for Learning Pufferfish<a class="headerlink" href="#an-ocean-of-environments-for-learning-pufferfish" title="Permalink to this heading">#</a></h1>
<p>Ocean is a small suite of environments that train from scratch in 30 seconds and render in a terminal. Each environment is a sanity check for a common implementation bug. Use Ocean as a quick verification test whenever you make small code changes.</p>
<a class="reference internal image-reference" href="../_images/ocean.png"><img alt="../_images/ocean.png" class="align-center" src="../_images/ocean.png" style="width: 100%;" /></a>
<p><strong>Memory:</strong> The agent is shown one binary token at a time and must recite them back after a pause. Do not make the sequence too long or you start testing credit assignment.</p>
<p><strong>Stochasticity:</strong> The agent is rewarded for learning a particular nondeterministic action distribution. Do not use an architecture with memory or the agent can solve the task without stochasticity.</p>
<p><strong>Exploration:</strong> The agent is rewarded for guessing a specific binary sequence. Do not tune your entropy coefficients higher than you would use in your actual environments, since that is the point of the test.</p>
<p><strong>Bandit:</strong> The agent is rewarded for solving a multiarmed bandit problem. This environment is included for historical importance. Any reasonable implementation should solve the default setting.</p>
<p><strong>Squared:</strong> The agent is rewarded for moving to targets that spawn around the edges of a square. There are settings to test memory, exploration, and stochasticity separately or jointly to help you prod at deeper issues with your implementation.</p>
<p>This project is heavily inspired by BSuite, a DeepMind project with similar if more benchmarky goals. BSuite was a bit too heavy for my liking and didn‚Äôt fit the niche of a quick and portable verification suite.</p>
<p>I had a few issues designing these. The memory task is apparently a standard RNN copying task (I would be surprised if it weren‚Äôt). But it‚Äôs a bit different in an RL context because you still have to learn credit assignment. I don‚Äôt think there is a way to fully isolate learning only memory outside of a simple 1-step problem. Try increasing the memory sequence length or delay and you will quickly find that the problem gets harder to learn.</p>
<p>The exploration environment is the only one that just worked. You can increase the password length and the problem gets harder to learn at about the rate you would expect. It‚Äôs just a guess and check, so once you happen to get the password right once, the goal is to learn from that single instance as much as possible. Any prioritized replay would trivialize the problem.</p>
<p>The stochastic environment took the longest. Initially, I was looking for one where the optimal policy was still stochastic and nontrivial even if the agent had memory. I could not figure out how to make one of these, and Twitter seems to think it‚Äôs impossible. They‚Äôre probably right, though you might be able to alter the setup conditions a bit, still test for the same thing, and have something that works better. For now, this is a quick and consistent test.</p>
<p>I wrote the bandit environment earlier in the project, and it seems kind of useful, so I left it in the release. Probably a good idea to have at least some version of a problem this historically important easily accessible in PufferLib.</p>
<p>I wrote Squared over the summer. I‚Äôm rather fond of it as a test environment, since it is fairly scalable. You spawn at the center of a square and targets spawn around the outside. You get a reward the first time you hit each target and are teleported to the center whenever you hit a target. This means that the optimal policy is stochastic: you place equal probability on moving towards each target and then deterministically move towards the target you have selected. It‚Äôs interesting because the optimal policy is stochastic in some states and deterministic in others. You can also turn the problem into a memory test by using a recurrent network. In any event, it‚Äôs similar to the bandit problem in that it combines elements of the simpler tests, but it‚Äôs a bit more tunable and interpretable.</p>
<p>Let me know if you have other ideas for useful test environments. Lately, I‚Äôve landed on either very simple or very complex environments as being the most useful for research. Many of the tasks in the middle (looking at you Atari) are too slow to be useful as quick tests and too simple to test interesting ideas.</p>
</section>
<section id="pufferlib-0-5-a-bigger-envpool-for-growing-puffers">
<h1>PufferLib 0.5: A Bigger EnvPool for Growing Puffers<a class="headerlink" href="#pufferlib-0-5-a-bigger-envpool-for-growing-puffers" title="Permalink to this heading">#</a></h1>
<p>This is what reinforcement learning does to your CPU utilization:</p>
<figure class="align-default">
<img alt="../_images/0-5_blog_header.png" src="../_images/0-5_blog_header.png" />
</figure>
<p>You wouldn‚Äôt pack a box this way, right? With PufferLib 0.5, we are releasing a Python implementation of EnvPool to solve this problem. <strong>TL;DR: ~20% performance improvement across most workloads, up to 2x for complex environments, and native multiagent support.</strong></p>
<figure class="align-default">
<img alt="../_images/0-5_blog_envpool.png" src="../_images/0-5_blog_envpool.png" />
</figure>
<p>If you just want the enhancements, you can pip install -U pufferlib. But if you‚Äôd like to see a bit behind the curtain, read on!</p>
<section id="the-simulation-crisis">
<h2>The Simulation Crisis<a class="headerlink" href="#the-simulation-crisis" title="Permalink to this heading">#</a></h2>
<p>You want to do some RL research, so you install Atari. Say it runs at 1000 steps/second on 1 core and 5000 steps/second on 6 cores. Now, you decide you want to work on a more interesting environment and happen upon Neural MMO, a brilliant project that must have been developed by a truly fantastic team. It runs at 1500 steps/second ‚Äì faster than Atari! So you scale it up to 6 cores and it runs at ‚Ä¶ 1800 steps per second. What gives?</p>
<p>The problem is that environments simulated on different cores do not run at the same speed. Even if they did, many modern CPUs have cores that run at different speeds. Parallelization overhead is mostly the sum of:
-  Launching/synchronization overhead. This is roughly 0.1 ms per process and is linear in the number of processes. At ~100 steps per second, you can ignore it. At &gt;10,000 steps/second, it is the main limiting factor.
- Environment variance. This is defined by the ratio mu/std of the environment simulation time and scales with the square root of the number of processes. For 24 processes, 10% std is 20% overhead and 100% std is 300% overhead.
- Different core speeds. Many modern CPUs, especially Intel desktop series processors, feature additional cores that are ~20% slower than the main cores.
- Model latency. This is the time taken to transfer observations to GPU, run the model, and transfer actions to CPU. It is not technically part of multiprocesssing overhead, but naive implementations will leave CPUs idle during model inference.</p>
<p>As a rule of thumb, simple RL environments have &lt; 10% variance because the code is always simulating roughly the same thing. Complex environments, especially ones with variable numbers of agents, can have &gt; 100% variance because different code runs depending on the current state. On the other hand, if your environment has 100 agents, you are effectively running 100x fewer simulations for the same data, so launching/synchronization overhead is lower.</p>
</section>
<section id="the-solution">
<h2>The Solution<a class="headerlink" href="#the-solution" title="Permalink to this heading">#</a></h2>
<p>Run multiple environments per process if you have &gt; ~2000 sps environment with variance &lt; ~10%. This will reduce the impact of launching/synchronization overhead and also reduces variance because you are summing over samples. In PufferLib, we typically enable this only for environments &gt; ~5000 sps because of interactions with the optimizations below.</p>
<p>Simulate multiple buffers of environments so that one buffer is running while your model is processing observations from the other. This technique was introduced by <a class="reference external" href="https://github.com/alex-petrenko/sample-factory">https://github.com/alex-petrenko/sample-factory</a> and does not speed up simulation, but it allows you to interleave simulations from two sets of environments. It‚Äôs a good trick, but it is superseded by the final optimization, which is faster and simpler.</p>
<p>Run a pool of environments and sample from the first ones to finish stepping. For example, if you want a batch of 24 observations, you might run 64 environments. At each step, the 24 for which you have computed actions are going to take a while to simulate, but you can still select the fastest 24 from the other 64-24=40 environments. This technique was introduced by <a class="reference external" href="https://github.com/sail-sg/envpool">https://github.com/sail-sg/envpool</a> and is massively effective, but the original implementation is only for specific C/C++ environments. PufferLib‚Äôs implementation is in Python, so it is slower, but it works for arbitrary Python environments and includes native multiagent support.</p>
</section>
<section id="experiments">
<h2>Experiments<a class="headerlink" href="#experiments" title="Permalink to this heading">#</a></h2>
<p>To evaluate the performance of different backends, I am using a 13900k (24 cores) on a max specced Maingear desktop running a minimal Debian 12 install. We test 9 different simulated environments: 1e-2 to 1-4 mean delay with 0-100% delay std. For each environment, we spawn 1, 6, 24, 96, and 192 processes for each backend tested (Gymnasium‚Äôs and Pufferlib‚Äôs serial and multiprocessing implementations + Pufferlib‚Äôs pool). We also have Ray implementations compatible with our pooling code, but that will be a separate post. Additionally, PufferLib implementations sweep over (1, 2, 4) environments per process and PufferLib pool will compute 24 observations at a time. We do not consider model latency, which can yield another 2x relative performance for pooling on specific workloads.</p>
<figure class="align-default">
<img alt="../_images/0-5_blog_envpool.png" src="../_images/0-5_blog_envpool.png" />
</figure>
<p>9 groups of bars, each for one environment. 5 groups of bars per environment, each for a specific number of processes. The serial Gymasium/PufferLib experiments match in all cases. The best PufferLib settings are 10-20% faster than the best Gymasium settings for all workloads and can be up to 2x faster for environments with a high standard deviation in important cases (for instance, you may not want to run 192 copies of heavy environments). Again, this is before even considering the time saved by interleaving with the model forward pass.</p>
<p>All of the implementations start to dip ~10% at 1,000 steps/second and ~50% at 10,000 steps/second. To make absolutely sure that this overhead is unavoidable, I reimplemented the entire pool architecture as minimally as possible, without any of the environment wrapper or data transfer overhead:</p>
<p>SPS: 10734.36 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 1 batch_size: 1 sync: False
SPS: 11640.42 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 1 batch_size: 1 sync: True
SPS: 32715.65 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 6 batch_size: 6 sync: False
SPS: 27635.31 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 6 batch_size: 6 sync: True
SPS: 22681.48 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 24 batch_size: 6 sync: False
SPS: 26183.73 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 24 batch_size: 24 sync: False
SPS: 30120.75 envs_per_worker: 1 delay_mean: 0 delay_std: 0 num_workers: 24 batch_size: 6 sync: True</p>
<p>As it turns out, Python‚Äôs multiprocessing caps around 10,000 steps per second per worker. There is still room for improvement by running more environments per process, but at this speed, small optimizations to the data processing code start to matter much more.</p>
</section>
<section id="technical-details-and-gotchas">
<h2>Technical Details and Gotchas<a class="headerlink" href="#technical-details-and-gotchas" title="Permalink to this heading">#</a></h2>
<p>PufferLib‚Äôs vectorization library is extremely concise ‚Äì around 800 lines for serial, multiprocessing, and ray backends with support for PufferLib‚Äôs Gymnasium and PettingZoo wrappers. Adding envpool only required changing around 100 lines of code but required a lot of performance testing:
Don‚Äôt use multiprocessing.Queue. There‚Äôs no fast way to poll which processes are done. Instead, use multiprocessing.Pipe and poll with selectors. I have not seen noticeable overhead from this in any of my tests.
Don‚Äôt use time.sleep(), as this will trigger context switching, or time.time(), as this will include time spent on other processes. Use time.process_time() if you want an equal slice per core or count to ~150M/second (time it on your machine) if you want a fixed amount of work.</p>
<p>The ray backend was extremely easy to implement thanks to ray.wait(). It is unfortunately too slow for most environments, but I wish standard multiprocessing used the Ray API, if not the architecture. The library itself has some cleanup issues that can cause crashes during heavy performance tests, which is why results are not included in this post.</p>
<p>There‚Äôs one other thing I want to mention for people looking at the code. I was doing some experimental procedural stuff testing different programming paradigms, so the actual class interfaces are in __init__. It‚Äôs pretty much equivalent to one subclass per backend.</p>
</section>
</section>
<section id="pufferlib-0-4-ready-to-take-on-bigger-fish">
<h1>PufferLib 0.4: Ready to Take on Bigger Fish<a class="headerlink" href="#pufferlib-0-4-ready-to-take-on-bigger-fish" title="Permalink to this heading">#</a></h1>
<p>PufferLib 0.4 is out now! Make your RL environments and libraries play nice with one-line wrappers, pain-free vectorization, and more.</p>
<div class="sd-card sd-sphinx-override sd-w-75 sd-mt-4 sd-mb-2 sd-ml-auto sd-mr-auto sd-shadow-sm sd-card-hover sd-text-center docutils">
<div class="sd-card-body docutils">
<p class="sd-card-text"><strong>Click to Demo PufferLib in Colab</strong></p>
</div>
<a class="sd-stretched-link reference external" href="https://colab.research.google.com/drive/1l1qLjerLwYoLjuKNr9iVc3TZ8gW2QVnz?usp=sharing"></a></div>
<dl class="simple">
<dt><strong>New Features</strong></dt><dd><ul class="simple">
<li><p>One-line wrappers for your Gym and PettingZoo environments</p></li>
<li><p>Serial, Multiprocessing, and Ray vectorization backends</p></li>
<li><p>PufferTank, a container preloaded with PufferLib and common environments</p></li>
</ul>
</dd>
</dl>
<p>More importantly, we have rewritten the entire core for simplicity and extensibility. While this is not a flashy new feature, you will notice significantly fewer rough edges working with PufferLib. For example, your Gym environments are no longer converted to PettingZoo environment internally, and your discrete action spaces are no longer returned as MultiDiscrete: WYSIWYG.</p>
<section id="emulation">
<h2>Emulation<a class="headerlink" href="#emulation" title="Permalink to this heading">#</a></h2>
<p>Previously, PufferLib required you to wrap your environment class in a binding, which then provided creation and additional utilities. Now, you pass in a Gym/PettingZoo environment and get back a Gym/PettingZoo environment. All of the benefits described in our 0.2 blog post are included.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pufferlib.emulation</span>
<span class="kn">import</span> <span class="nn">nle</span><span class="o">,</span> <span class="nn">nmmo</span>

<span class="k">def</span> <span class="nf">nmmo_creator</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">pufferlib</span><span class="o">.</span><span class="n">emulation</span><span class="o">.</span><span class="n">PettingZooPufferEnv</span><span class="p">(</span><span class="n">env_creator</span><span class="o">=</span><span class="n">nmmo</span><span class="o">.</span><span class="n">Env</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nethack_creator</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">pufferlib</span><span class="o">.</span><span class="n">emulation</span><span class="o">.</span><span class="n">GymPufferEnv</span><span class="p">(</span><span class="n">env_creator</span><span class="o">=</span><span class="n">nle</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">NLE</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="vectorization">
<h2>Vectorization<a class="headerlink" href="#vectorization" title="Permalink to this heading">#</a></h2>
<p>Previously, PufferLib‚Äôs vectorization expected a binding object. Now, you pass it an environment creation function (as above) or a Gym/PettingZoo PufferEnv, if you prefer to subclass directly. Compared to 0.2 PufferLib includes Serial and Multiprocessing backends, in addition to Ray.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pufferlib.vectorization</span>
<span class="kn">import</span> <span class="nn">nmmo</span>

<span class="n">vec</span> <span class="o">=</span> <span class="n">pufferlib</span><span class="o">.</span><span class="n">vectorization</span><span class="o">.</span><span class="n">Multiprocessing</span> <span class="c1"># Or Serial or Ray</span>
<span class="n">envs</span> <span class="o">=</span> <span class="n">vec</span><span class="p">(</span><span class="n">nmmo_creator</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">envs_per_worker</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Synchronous API</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">envs</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

<span class="c1"># Async API</span>
<span class="n">envs</span><span class="o">.</span><span class="n">async_reset</span><span class="p">()</span>
<span class="n">obs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">envs</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="puffertank">
<h2>PufferTank<a class="headerlink" href="#puffertank" title="Permalink to this heading">#</a></h2>
<p>Many common RL environments are notoriously hard to set up and use. PufferTank provides containers with several such popular environments tested to work with PufferLib. These are preloaded onto base images so you can build the container over a coffee break.</p>
</section>
<section id="policies">
<h2>Policies<a class="headerlink" href="#policies" title="Permalink to this heading">#</a></h2>
<p>Previously, PufferLib required you to subclass a PyTorch base class for your models. Now, you can use vanilla PyTorch policies. We still provide a base class as an option, which allows you to use another of our wrappers to handle recurrence for you. Pass your model to our wrappers and we will convert to framework-specific APIs for you.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cleanrl_policy</span> <span class="o">=</span> <span class="n">pufferlib</span><span class="o">.</span><span class="n">frameworks</span><span class="o">.</span><span class="n">cleanrl</span><span class="o">.</span><span class="n">Policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="error-handling">
<h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this heading">#</a></h2>
<p>Previously, PufferLib applied expensive runtime checks to all environments by default. These could be disabled by running with -O. This was inconvenient and easily forgotten. Now, these checks only run once at startup with negligible overhead. Thus far, we have observed no bugs with the new version that would have been caught by the previous checks.</p>
</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this heading">#</a></h2>
<p>We have added sane default installations, setup, and policies for several more environments. Check our home page for an updated list.</p>
<p>The new environment and policy changes means that PufferLib no longer breaks serialization. This is useful for saving environment and model states.</p>
<p>We have written an optimized flatten and unflatten function for handling observation and actions. This was previously a bottleneck for environments with complex spaces. Expect a separate post on this, since it was an interesting case study for Python extension options.</p>
<p>We have an experimental custom CleanRL derivative to correctly handle environments with variable numbers of agents, without training on padding. Doing this simply has been a longstanding challenge in RL. More on this once it is more stable.</p>
<p>Join us on Discord and tell us your pain points. We might just fix them.</p>
</section>
</section>
<section id="pufferlib-0-2-ready-to-take-on-the-big-fish">
<h1>PufferLib 0.2: Ready to Take on the Big Fish<a class="headerlink" href="#pufferlib-0-2-ready-to-take-on-the-big-fish" title="Permalink to this heading">#</a></h1>
<p>PufferLib‚Äôs goal is to make reinforcement learning on complex game environments as simple as it is on Atari. We released version 0.1 as a preliminary API with limited testing. Now, we‚Äôre excited to announce version 0.2, which includes dozens of bug fixes, better testing, a streamlined API, and a working demo on CleanRL.</p>
<section id="problem-statement">
<h2>Problem Statement<a class="headerlink" href="#problem-statement" title="Permalink to this heading">#</a></h2>
<p>To understand the need for PufferLib, let‚Äôs consider the difference between Atari and one of the most complex game environments out there: Neural MMO. Atari is deterministic, fully observable, and single-agent, with relatively short time horizons and simple observation and action spaces. In contrast, Neural MMO is nondeterministic, only partially observable, and features large and variable agent populations, with longer time horizons and hierarchical observation and action spaces.</p>
<p>Most RL frameworks are designed with Atari in mind, resulting in limited support for multiple agents, complex observation and action spaces, and a bias towards small models with fewer than 10 million parameters. This makes it challenging for researchers to tackle more complex environments and leads many to focus exclusively on Atari and other simple environments.</p>
</section>
<section id="cleanrl-demos">
<h2>CleanRL Demos<a class="headerlink" href="#cleanrl-demos" title="Permalink to this heading">#</a></h2>
<p>For our initial demo, we ran Neural MMO on CleanRL‚Äôs single-file Proximal Policy Optimization (PPO) implementation designed for Atari by replacing only the vectorized environment creation code, without considering any of Neural MMO‚Äôs complexities. For ease of experimentation, we have since wrapped CleanRL in a function and added additional logging. The latest version also includes double-buffering, an asynchronous environment simulation approach from the SampleFactory paper. To ensure the accuracy of our results, we maintain a public WandB profile with current baselines, including Atari results as a correctness check.</p>
</section>
<section id="pufferlib-emulation">
<h2>PufferLib Emulation<a class="headerlink" href="#pufferlib-emulation" title="Permalink to this heading">#</a></h2>
<p>The key idea behind PufferLib is emulation, or wrapping a complex environment to appear simple, thereby ‚Äúemulating‚Äù an Atari-like game from the perspective of the reinforcement learning framework. This approach handles environment complexity in a wrapper layer instead of natively by the reinforcement learning framework, allowing us to use simple reinforcement learning code with an internally complex environment.</p>
<p>We will use Neural MMO as a running example here. Neural MMO has hierarchical observation and action spaces, while most reinforcement learning frameworks expect fixed size vectors or tensors. PufferLib flattens observations and action spaces to conform to this expectation, without losing any structural information: both observations and actions are unflattened right before they are required. Reinforcement learning frameworks also expect vectorized environments to have a constant number of agents. PufferLib pads Neural MMO‚Äôs variable population to a fixed number of agents and also ensures they appear in the same sorted order. Finally, PufferLib also handles some subtleties in multiagent environment termination signals that are a common source of bugs. PufferLib works with single-agent environments, too!</p>
<p>Creating a PufferLib binding for a new environment is straightforward - simply provide the environment class and name in the pufferlib.emulation.Binding() function. Here‚Äôs an example binding for Neural MMO:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pufferlib</span><span class="o">.</span><span class="n">emulation</span><span class="o">.</span><span class="n">Binding</span><span class="p">(</span>
    <span class="n">env_cls</span><span class="o">=</span><span class="n">nmmo</span><span class="o">.</span><span class="n">Env</span><span class="p">,</span>
    <span class="n">env_name</span><span class="o">=</span><span class="s1">&#39;Neural MMO&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The Binding class also accepts optional arguments to disable certain emulation features if they‚Äôre not needed. Additional features include hooks for observation featurization and reward shaping, as well as the ability to suppress output and errors from the environment to avoid excessive logging.</p>
</section>
<section id="pufferlib-vectorization">
<h2>PufferLib Vectorization<a class="headerlink" href="#pufferlib-vectorization" title="Permalink to this heading">#</a></h2>
<p>Most reinforcement learning libraries, including CleanRL, require vectorized environments that stack observation tensors across environments and split stacked actions across all environments. While a few options technically support multiagent environments, they are prone to difficult and finicky errors that are costly to debug. PufferLib takes a different approach by providing a wrapper with native support for multiagent environments. You can specify the number of CPU cores and the number of environments per core.</p>
<p>To use PufferLib‚Äôs vectorization, create a VecEnvs object by passing in a binding and the number of workers and environments per worker:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pufferlib</span><span class="o">.</span><span class="n">vectorization</span><span class="o">.</span><span class="n">RayVecEnv</span><span class="p">(</span>
   <span class="n">binding</span><span class="p">,</span>
   <span class="n">num_workers</span><span class="o">=</span><span class="n">num_cores</span><span class="p">,</span>
   <span class="n">envs_per_worker</span><span class="o">=</span><span class="n">envs_per_worker</span>
<span class="p">)</span>
</pre></div>
</div>
<p>All other popular vectorization implementations are based on native multiprocessing. This works well for bug-free environments that adhere perfectly to the Gym API but quickly becomes cumbersome outside of this ideal setting. Multiprocessing does not scale natively beyond a single machine, eats stack traces from the environments, and does not allow direct access to remote environments outside of the multiprocessed functions. PufferLib‚Äôs vectorization is backed by Ray, which scales natively to multiple machines, provides correct stack traces, and allows arbitrary access to individual remote environments. At the same time, it is shorter and simpler than any multiprocessed implementation. This vectorization approach makes it easy to reset environments with new maps, convey task specifications, or receive logging information that is not suitable for the infos field. We will cover this in a subsequent post with more detail.</p>
<p>The one major downside to using Ray as a backend is that it is not particularly fast. Ray itself caps at a few hundred to a few thousand remote calls per second. Currently, this is the price that has to be paid for simplicity and generality. Using larger batch sizes that require many simulated environments per core and employing async techniques like double-buffering can help mitigate this issue. Ultimately, as RL continues to scale up, the problem will solve itself as models become the bottleneck.</p>
</section>
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Permalink to this heading">#</a></h2>
<p>This release represents only a small part of what RL could be with better tooling. Here are some of our plans for future development:</p>
<p><strong>Emulation features:</strong> We plan to add native support for team-based environments and better passthrough support for accessing any environment-specific features outside of Gym/PettingZoo. There is also room for performance optimization in this area.</p>
<p><strong>Algorithmic features:</strong>  We aim to provide PufferLib-compatible modules for commonly used methods in complex environments research, such as historical self-play, multiplayer skill-rating, and curriculum learning.</p>
<p><strong>More integrations:</strong>  In our initial release, we included both RLlib and CleanRL support. While we still provide an RLlib binding, we have focused on CleanRL as a faster testing mechanism in the early stages of development. However, PufferLib is designed to be easy to integrate with new learning libraries, and we plan to provide baselines for these as well.</p>
<p><strong>Versioning Compatibility:</strong> The rapid progress of Gym/Gymnasium has created compatibility conflicts between specific environments, gym versions, and learning library dependencies. We are still on an old version of Gym from before all of this happened and are slowly increasing test coverage and compatibility with new versions.</p>
<p>Blog post by Joseph Suarez. Thank you to Ryan Sullivan for feedback and suggestions. Join our Discord if you are interested in contributing to PufferLib!</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="ocean.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Squared</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, Joseph Suarez
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/design-tabs.js"></script>
    </body>
</html>